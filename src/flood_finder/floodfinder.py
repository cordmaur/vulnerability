"""
Implements the FloodSeeker class
This module requires scikit-learn == 1.2.2
"""
import logging
from typing import Optional, Tuple, Union
from pathlib import Path
import joblib
import skimage
from sklearn.ensemble import RandomForestRegressor

from tqdm.notebook import tqdm

from shapely import Polygon
import xarray as xr
import rioxarray as xrio  # pylint: disable=unused-import
from .imagery import ImageFinder
from .logging import create_logger


class FloodFinder:
    """Docstring"""

    def __init__(
        self,
        model_path: Union[str, Path],
        output_path: Union[str, Path],
        aoi: Polygon,
        time_range: Optional[str] = None,
        recurrence_threshold: int = 10,
        lee_size: Optional[int] = 7,
    ):
        """

        Args:
            aoi (Polygon): _description_
            time_range (Optional[str], optional): _description_. Defaults to None.
        """
        self.logger = create_logger(
            name=__name__, level=logging.DEBUG, folder=output_path, fname=None
        )

        self.output_path = Path(output_path)
        self.logger.info("Starting FloodFinder instance for %s", self.output_path.name)

        self.image_finder = ImageFinder()
        self.classifier = joblib.load(model_path)

        self.s1imagery = self.image_finder.get_s1_images(
            aoi=aoi, time_range=time_range, lee_size=lee_size
        )
        self.gsw = self.image_finder.get_water_baseline(
            aoi=aoi, asset="recurrence"
        ).compute()

        self.permanent_water = self.gsw > recurrence_threshold

        self.floods = xr.Dataset()
        self.waters = xr.Dataset()

    def adjust_coords(self, da: xr.DataArray) -> xr.DataArray:
        """
        Make sure the array has the same coords as self.permanent_water
        Additionally, get rid of unimportant coords
        Args:
            da (xr.DataArray): DataArray to be ajusted

        Returns:
            xr.DataArray: DataArray with the same coordinates as permanent_water
        """
        da = da.assign_coords(
            {"x": self.permanent_water.x, "y": self.permanent_water.y}
        )
        drop_vars = set(da.coords.keys())
        drop_vars = drop_vars - {"x", "y", "epsg"}
        da = da.drop_vars(drop_vars)
        return da

    def seek(self, date: str) -> Tuple[xr.DataArray]:
        """_summary_

        Args:
            date (str): _description_

        Returns:
            xr.DataArray: XArray containing the flood pixels
        """
        self.logger.info("Seeking for flood in date: %s", date)

        # get the corresponding image
        s1img = self.s1imagery[date]

        s1img = s1img.rio.reproject(
            dst_crs="epsg:4326", shape=self.permanent_water.shape
        )
        water = FloodFinder.predict_water(self.classifier, s1img, thresh=0.5)

        flood_arr = (water.data - self.permanent_water.astype("int").data) == 1

        # clean the prediction
        kernel = skimage.morphology.square(5)
        flood_arr = skimage.morphology.opening(flood_arr, footprint=kernel)
        flooded = self.permanent_water.copy()
        flooded.data = flood_arr

        # compat the coords
        flooded = self.adjust_coords(flooded).rio.write_nodata(0)
        water = self.adjust_coords(water).rio.write_nodata(0)

        return flooded, water

    def find_floods(self):
        """
        Find the floods for the time_range specified and write the results to self.floods and
        self.waters
        """

        for date in tqdm(self.s1imagery.dates):
            flood, water = self.seek(date)
            self.floods[date] = flood
            self.waters[date] = water

        self.floods = self.floods.astype("int").rio.set_crs("epsg:4326")
        self.waters = self.waters.astype("int").rio.set_crs("epsg:4326")

        self.floods.rio.to_raster(self.output_path / "floods.tif", compress="DEFLATE")
        self.waters.rio.to_raster(self.output_path / "waters.tif", compress="DEFLATE")

    @staticmethod
    def predict_water(
        clf: RandomForestRegressor,
        img: xr.DataArray,
        thresh: float = None,
    ):
        """_summary_

        Args:
            clf (RandomForestRegressor): _description_
            img (xr.DataArray): _description_
            thresh (float, optional): _description_. Defaults to None.

        Returns:
            _type_: _description_
        """
        # Calculate the reference

        data = img.data.reshape(2, -1).transpose(1, 0)
        probs = clf.predict_proba(data).transpose(1, 0).reshape(img.shape)

        result = img.sel(band="vv").copy()
        if thresh is None:
            result.data = probs
        else:
            result.data = probs[1] > thresh

        return result


# def calc_floods(clf, ref_img, imgs, bounds, crs, lee_size):

#     baseline = calc_baseline(ref_img, clf, bounds, crs, lee_size)

#     floods = []
#     preds = []
#     for i, img in enumerate(imgs):

#         actual = predict_water(clf, img, thresh=0.5, lee_size=lee_size)
#         flooded = (actual.astype('int') - baseline.astype('int')) == 1

#         # clean the prediction
#         kernel = skimage.morphology.square(5)
#         flooded.data = skimage.morphology.opening(flooded.data, footprint=kernel)

#         floods.append(flooded)
#         preds.append(actual)

#     return floods, preds, baseline
