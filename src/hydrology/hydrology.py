# include necessary imports
import struct
from typing import List, Tuple, Dict, Optional, Union, Callable, Type
from functools import partial, lru_cache

import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter

import numpy as np
import pandas as pd
from scipy import stats

import pyodbc
from azure.identity import DefaultAzureCredential

# from .memoization import memoize
from .utils import months_between_dates, logit_formatter, logit, non_interactive_backend


class LogPearson3:
    name = "Log-Pearson 3"

    def __init__(self, *args):
        self.args = args

    def fit(self, x):
        args = stats.pearson3.fit(np.log(x))
        return args

    def cdf(self, x, *args):
        if len(args) == 0:
            args = self.args

        return stats.pearson3.cdf(np.log(x), *args)

    def pdf(self, x, *args):
        if len(args) == 0:
            args = self.args

        # PDF of the log-transformed data, adjusted for the log transformation
        log_x = np.log(x)
        return stats.pearson3.pdf(log_x, *args) / x

    def ppf(self, x, *args):
        if len(args) == 0:
            args = self.args

        return np.exp(stats.pearson3.ppf(x, *args))

    def __str__(self):
        return self.name

    def __call__(self, *args):
        self.args = args
        return self


class Hydrology:
    """
    This class is used to get discharge data from the Hydrology database.
    """

    # specify hydrologycal year for some states
    # default is from october-september
    hydrological_year = {"RS": 1, "default": 10}

    # list of distributions to adjust
    default_distrs = ["lognorm", "gumbel_r", LogPearson3()]

    rename_columns = {
        "vazao_val": "Vazao",
        "vazao_data": "Data",
    }

    def __init__(self):
        self._connect_datalake()

    ###### INIT Methods ######
    def _connect_datalake(self):
        # get Microsoft credentials: This code will pop a browser window
        credential = DefaultAzureCredential(
            exclude_interactive_browser_credential=False
        )
        token_bytes = credential.get_token(
            "https://database.windows.net/.default"
        ).token.encode("UTF-16-LE")

        token_struct = struct.pack(
            f"<I{len(token_bytes)}s", len(token_bytes), token_bytes
        )
        connection_string = """Driver={ODBC Driver 17 for SQL Server};
        Server=synanaprod001-ondemand.sql.azuresynapse.net;
        Database=syndb_hidro;Encrypt=yes;TrustServerCertificate=no;
        Connection Timeout=30"""

        self.conn = pyodbc.connect(  # pylint: disable=I1101
            connection_string, attrs_before={1256: token_struct}
        )

    # ------------------------------------------------------
    #  Static Hydrological Methods
    # ------------------------------------------------------
    @staticmethod
    def get_hydrological_year(dt: pd.DatetimeIndex, month: int = 10) -> str:
        """Get the hydrological year as a string

        Args:
            dt (DatetimeIndex): Datetime of the measurement

        Returns:
            str: Hydrological year
        """

        # if dt.month >= month:
        #     s = f"{dt.year}/{dt.year + 1}"
        # else:
        #     s = f"{dt.year - 1}/{dt.year}"

        # return s
        df = pd.DataFrame(index=dt)
        df["position"] = df.index.month >= month
        df.loc[df["position"], "ref"] = df.loc[df["position"]].index.year
        df.loc[~df["position"], "ref"] = df.loc[~df["position"]].index.year - 1
        df["ref"] = df["ref"].astype("int")
        df["hydro_year"] = df["ref"].astype("str") + "/" + (df["ref"] + 1).astype("str")

        return df.set_index("hydro_year").index

    @staticmethod
    def get_hydrological_month(uf: str) -> int:
        """Get the hydrological month for a given state

        Args:
            uf (str): State abbreviation

        Returns:
            int: Hydrological month
        """
        if uf in Hydrology.hydrological_year:
            return Hydrology.hydrological_year[uf]
        else:
            return Hydrology.hydrological_year["default"]

    @staticmethod
    def fill_hydrological_year(data: pd.DataFrame, month: int):
        """Fill hydrological year column with data. Date must be the index.

        Args:
            data (pd.DataFrame): dataframe with discharge
            month (int): month to use for hydrological year

        Returns:
            pd.DataFrame: dataframe with hydrological year
        """
        f = partial(Hydrology.get_hydrological_year, month=month)
        data["Ano Hidro"] = data.index.map(f)
        return data

    @staticmethod
    def calc_peak_discharges(data: pd.DataFrame, hydrological_month: int = None):
        """Calculate the peak discharges for each hydrological year

        Args:
            data (pd.DataFrame): dataframe with discharge
            hydrological_month (int): hydrological month for use for in the hydrological year

        Returns:
            pd.DataFrame: dataframe with peak discharges
        """
        # Create hydrological year column
        data = Hydrology.fill_hydrological_year(data, hydrological_month)

        # Calculate peak discharges
        maximum = data.groupby(by="Ano Hidro").max()[["Vazao"]]

        # Join with original data
        maximum = maximum.reset_index().set_index(["Ano Hidro", "Vazao"])
        maximum = maximum.join(
            data.reset_index().set_index(["Ano Hidro", "Vazao"]), how="left"
        )

        # Drop duplicates
        maximum = maximum[~maximum.index.duplicated()]

        # Sort by discharge
        maximum = maximum.sort_values(by="Vazao", ascending=False)
        maximum = maximum.reset_index(drop=False)

        # Drop undiserable columns
        maximum = maximum.drop(columns=["NivelConsistencia", "EstacaoCodigo"])

        maximum["Vazao"] = maximum["Vazao"].astype("float64").round(1)

        return maximum

    # ------------------------------------------------------
    #  Static Stats Methods
    # ------------------------------------------------------
    @staticmethod
    def recurring_time(Q, distr, *params) -> float:  # pylint: disable=C0103
        """Calculate the return time of a value, given a
        distribution and its parameters.

        Args:
            Q (float): Value (Discharge)
            distr (scipy.distribution): The distribution object

        Returns:
            float: Recurring time
        """
        prob = 1 - distr.cdf(Q, *params)
        return 1 / prob

    @staticmethod
    def fit_distribution(
        data: pd.Series, distr: Union[str, Type]
    ) -> Tuple[float, float]:
        """Fit a distribution to a data set and return the parameters

        Args:
            data (pd.Series): Series with discharge data
            distr (str): scipy distribution

        Returns:
            Tuple[float, float]: parameters of the distribution
        """
        # Get the scipy distribution object from its name
        distribution = getattr(stats, distr) if isinstance(distr, str) else distr

        args = distribution.fit(data)

        return args

    @staticmethod
    def apply_distribution(
        maximum: pd.DataFrame,
        distr: str,
        # ax: plt.Axes,
        include_max_q: bool = True,
        round_value: int = 4,
    ):
        """Apply a distribution to a data set. This includes the RT (Recurring Time)
        column to the dataframe, and the corresponding chart.

        Args:
            data (pd.DataFrame): dataframe with discharge column
            distr (str): scipy distribution
            ax (plt.Axes): matplotlib axes
        """
        # Get the scipy distribution object from its name
        distribution = getattr(stats, distr) if isinstance(distr, str) else distr

        # Fit the distribution
        if include_max_q:
            args = Hydrology.fit_distribution(maximum["Vazao"], distr)
        else:
            args = Hydrology.fit_distribution(maximum["Vazao"][1:], distr)

        # add the RT column
        column_name = f"TR {distribution.name}"
        maximum[column_name] = round(
            maximum["Vazao"].apply(
                Hydrology.recurring_time, args=(distribution, *args)
            ),
            round_value,
        )

        # return the fitted args
        return dict(distr=distribution, args=args)

    @staticmethod
    def apply_empiric_rt(maximum: pd.DataFrame, round_value: int = 5):
        """Apply empirical RT to the dataframe

        Args:
            data (pd.DataFrame): dataframe with discharge column
        """
        # add the RT column
        column_name = "TR Empirico"
        n = len(maximum)
        maximum[column_name] = (n + 1) / (maximum.index + 1)
        maximum[column_name] = maximum[column_name].round(round_value)

    @staticmethod
    def calc_return_times(
        data: pd.DataFrame,
        hydrological_month: int,
        distrs: List[str] = None,
        include_max_q: bool = True,
    ) -> Tuple[pd.DataFrame, dict]:
        """Calculate the Return Times for the maximum Discharge values in each hydrological year

        Args:
            data (pd.DataFrame): dataframe with discharge
            hydrological_month (int): hydrological month for use for in the hydrological year
            distrs (List[str], optional): List of scipy distributions.
                If None, defaults to gumbel and lognormal.
        Returns:
           Tuple[pd.DataFrame: dataframe with RTs, dict: adjusted distrs]
        """
        if distrs is None:
            distrs = Hydrology.default_distrs

        # Get the maximum discharge for each hydrological year
        data = Hydrology.fill_hydrological_year(data, hydrological_month)
        maximum = Hydrology.calc_peak_discharges(data, hydrological_month)

        # apply the empirical RT
        Hydrology.apply_empiric_rt(maximum)

        # create a variable to store the fitting
        fits = {}
        for distr in distrs:
            fits[distr] = Hydrology.apply_distribution(maximum, distr, include_max_q)

        return maximum, fits

    # ------------------------------------------------------
    #  Static Plotting Methods
    # ------------------------------------------------------
    @staticmethod
    def plot_logit_values(probs: pd.Series, y: pd.Series, ax: plt.Axes):
        """
        Plot values in a scatter plot, but use logit scale in X

        Args:
            probs (pd.Series): Probabilities of exceedance (X axis)
            y (pd.Series): Discharge values
            ax (plt.Axes): Matplotlib Axes
        """

        ax.plot(
            logit(probs),
            y,
            marker="o",
            linestyle="none",
            markerfacecolor="none",
            label="Empirico",
            markeredgecolor="black",
            alpha=0.5,
        )

        # Define custom tick positions in logit space
        custom_ticks = np.array(
            [0.9999, 0.999, 0.99, 0.9, 0.5, 0.1, 0.01, 0.001, 0.0001]
        )
        custom_ticks_logit = logit(custom_ticks)

        # Set custom ticks
        ax.set_xticks(custom_ticks_logit)

        ax.xaxis.set_major_formatter(FuncFormatter(logit_formatter))

        # Set limits for x-axis (logit of 0.0001 and 0.9999)
        ax.set_xlim(logit(0.999), logit(0.001))
        ax.set_ylim(0, y.max() * 1.5)

        ax.grid(
            True, which="major", linestyle="-", linewidth="0.5", color="gray", alpha=0.5
        )

        ax.set_ylabel("Vazão (m³/s)")
        ax.set_xlabel("Probabilidade de Excedência (Tempos de Retorno em anos)")

    @staticmethod
    def plot_logit_distribution(
        distr: Union[str, Callable], args: Tuple, ax: plt.Axes, color: str
    ):
        """Plot the distribution where the probabilities are in logit scale in the X axis

        Args:
            distr (Union[str, Callable]): Name or the actual distribution (scipy)
            args (Tuple): Args for the distribution
            ax (plt.Axes): Axes to plot the distribution to
            color (str): Color for the line
        """
        # get the exceedance probability vector
        probs = np.linspace(0.002, 0.99, 100)

        # from the probabilities, calculate the discharges
        # NOTE that in ppf, the probability is not the exceedance, so we use 1 - prob
        qs = distr.ppf(1 - probs, *args)

        # When plotting, we will use the logit function
        ax.plot(
            logit(probs),
            qs,
            color=color,
            linestyle="-",
            marker="None",
            label=distr.name,
        )

        # Finally, we will adjust the y limits depending on the curve
        ymin, ymax = ax.get_ylim()
        new_ymax = qs[0] * 1.2
        ymax = ymax if ymax > new_ymax else new_ymax

        ax.set_ylim([ymin, ymax])

    @staticmethod
    def plot_distribution_curve(distr: Union[str, Type], args: Tuple, ax: plt.Axes):
        """Plot a distribution curve, with density probability on the X axis

        Args:
            distr (str|Callable): scipy distribution (string or actual distribution)
            args (Tuple[float, float]): parameters of the distribution
            ax (plt.Axes): matplotlib axes
        """

        # Get the scipy distribution object from its name
        distribution = getattr(stats, distr) if isinstance(distr, str) else distr

        # Calculate min and max x-values to plot
        min_x = distribution.ppf(0.001, *args)
        max_x = distribution.ppf(0.999, *args)
        x = np.linspace(min_x, max_x, 1000)

        ax.plot(
            x,
            distribution.pdf(x, *args),
            "r-",
            lw=2,
            label=f"Fitted {distribution.name}",
        )
        ax.legend()
        ax.set_title(f"Distribuição {distribution.name}")
        ax.set_xlabel("Vazão (m³/s)")
        ax.set_ylabel("Densidade de probabilidade")

    @staticmethod
    @non_interactive_backend
    def plot_histogram(data: pd.Series, ax: plt.Axes, distr: Optional[Dict] = None):
        """Plot a histogram

        Args:
            data (pd.DataFrame): dataframe with discharge column
            ax (plt.Axes): matplotlib axes
        """
        # plot the corresponding chart
        ax.hist(data, bins=10, density=True)

        # Set the title
        ax.set_title("Histograma de Vazão")

        # Plot the distribution curve
        if distr is not None:
            Hydrology.plot_distribution_curve(distr["distr"], distr["args"], ax)

        # Set the axis labels
        ax.set_xlabel("Vazão (m³/s)")
        ax.set_ylabel("Densidade de probabilidade")

    @staticmethod
    @non_interactive_backend
    def plot_logit_chart(rts: pd.Series, y: pd.Series, ax: plt.Axes, distrs: dict):
        """
        Plot a combined graph with the Empirical and the distribution curves
        In a logit X scale

        Args:
            rts (pd.Series): The recurring times (Empirical) to be plotted as points
            y (pd.Series): The corresponding discharges
            ax (plt.Axes): Matplotlib axes
            distrs (dict): Dictionary containing the scypy distribution and the fitting args
        """
        # First, plot the points, converting Recurring Times (rts) to probabilities
        Hydrology.plot_logit_values(1 / rts, y, ax=ax)

        # Get a listed colormap to use for the distributions
        cmap = plt.get_cmap("tab10")

        for i, key in enumerate(distrs):
            distribution, args = distrs[key].values()
            color = cmap(i)
            Hydrology.plot_logit_distribution(distribution, args, ax=ax, color=color)

        ax.legend()

    ###### MAIN PUBLIC METHODS ######
    @lru_cache(maxsize=32, typed=False)
    def get_discharge(self, station: int) -> pd.DataFrame:
        """Get discharge for a given station

        Args:
            station (int): station number

        Returns:
            pd.DataFrame: dataframe with discharge
        """
        # Query database to retrieve discharge records
        query = f"""SELECT EstacaoCodigo, NivelConsistencia, vazao_val, vazao_data
                    FROM hidro.pivotvazoes 
                    WHERE EstacaoCodigo = {station}"""

        # Read SQL query results into a DataFrame
        data = pd.read_sql(
            query,
            self.conn,
            parse_dates="vazao_data",
            dtype={
                "EstacaoCodigo": "int32",
                "NivelConsistencia": "uint8",
                "vazao_val": "float32",
            },
        )

        # Rename columns for clarity
        data = data.rename(columns=Hydrology.rename_columns)

        # Get highest quality level for each date
        keys = data[["Data", "NivelConsistencia"]].groupby("Data").max()
        keys = keys.reset_index(drop=False).set_index(["Data", "NivelConsistencia"])

        # Join data to keys
        data = data.set_index(["Data", "NivelConsistencia"])
        data = data.loc[keys.index].reset_index(drop=False)

        # Before seting Date as index, let's drop duplicates
        data = data.drop_duplicates(subset=["Data"])

        # Sort by date
        data = data.set_index("Data", drop=True).sort_index()

        # Round discharge values
        data["Vazao"] = data["Vazao"].round(2)

        # Drop NA rows
        data = data.dropna()

        return data

    def get_station_stats(self, station: int) -> Dict:
        """Get statistics for a given station

        Args:
            station (int): station number

        Returns:
            Dict: station statistics
        """

        # Get discharge data
        q = self.get_discharge(station)

        # count values by month
        q_count = q.groupby([q.index.year, q.index.month]).size()
        q_count = q_count[q_count >= 28]

        total_months = months_between_dates(
            pd.to_datetime(q.index.min()), pd.to_datetime(q.index.max())
        )

        results = {
            "complete_months": len(q_count),
            "years": int(len(q_count) / 12),
            "start_year": q.index.min().strftime("%Y/%m"),
            "end_year": q.index.max().strftime("%Y/%m"),
            "total_months": total_months,
            "missing_perc": f"{(100*(total_months - len(q_count)) / total_months):.2f}%",
        }
        return results
