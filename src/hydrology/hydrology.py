# include necessary imports
import struct
from typing import List, Tuple
from functools import partial

import matplotlib.pyplot as plt

import numpy as np
import pandas as pd
from scipy import stats

import pyodbc
from azure.identity import DefaultAzureCredential


class Hydrology:
    """
    This class is used to get discharge data from the Hydrology database.
    """

    # specify hydrologycal year for some states
    # default is from october-september
    hydrological_year = {"RS": 1, "default": 10}

    # list of distributions to adjust
    default_distrs = ["gumbel_r", "lognorm"]

    rename_columns = {
        "vazao_val": "Vazao",
        "vazao_data": "Data",
    }

    def __init__(self):
        self._connect_datalake()

    ###### INIT Methods ######
    def _connect_datalake(self):
        # get Microsoft credentials: This code will pop a browser window
        credential = DefaultAzureCredential(
            exclude_interactive_browser_credential=False
        )
        token_bytes = credential.get_token(
            "https://database.windows.net/.default"
        ).token.encode("UTF-16-LE")

        token_struct = struct.pack(
            f"<I{len(token_bytes)}s", len(token_bytes), token_bytes
        )
        connection_string = """Driver={ODBC Driver 17 for SQL Server};
        Server=synanaprod001-ondemand.sql.azuresynapse.net;
        Database=syndb_hidro;Encrypt=yes;TrustServerCertificate=no;
        Connection Timeout=30"""

        self.conn = pyodbc.connect(  # pylint: disable=I1101
            connection_string, attrs_before={1256: token_struct}
        )

    ###### Static Methods ######
    @staticmethod
    def get_hydrological_year(dt: pd.DatetimeIndex, month: int = 10) -> str:
        """Get the hydrological year as a string

        Args:
            dt (DatetimeIndex): Datetime of the measurement

        Returns:
            str: Hydrological year
        """

        # if dt.month >= month:
        #     s = f"{dt.year}/{dt.year + 1}"
        # else:
        #     s = f"{dt.year - 1}/{dt.year}"

        # return s
        df = pd.DataFrame(index=dt)
        df["position"] = df.index.month >= month
        df.loc[df["position"], "ref"] = df.loc[df["position"]].index.year
        df.loc[~df["position"], "ref"] = df.loc[~df["position"]].index.year - 1
        df["ref"] = df["ref"].astype("int")
        df["hydro_year"] = df["ref"].astype("str") + "/" + (df["ref"] + 1).astype("str")

        return df.set_index("hydro_year").index

    @staticmethod
    def get_hydrological_month(uf: str) -> int:
        """Get the hydrological month for a given state

        Args:
            uf (str): State abbreviation

        Returns:
            int: Hydrological month
        """
        if uf in Hydrology.hydrological_year:
            return Hydrology.hydrological_year[uf]
        else:
            return Hydrology.hydrological_year["default"]

    @staticmethod
    def fill_hydrological_year(data: pd.DataFrame, month: int):
        """Fill hydrological year column with data. Date must be the index.

        Args:
            data (pd.DataFrame): dataframe with discharge
            month (int): month to use for hydrological year

        Returns:
            pd.DataFrame: dataframe with hydrological year
        """
        f = partial(Hydrology.get_hydrological_year, month=month)
        data["Ano Hidro"] = data.index.map(f)
        return data

    @staticmethod
    def calc_peak_discharges(data: pd.DataFrame, hydrological_month: int = None):
        """Calculate the peak discharges for each hydrological year

        Args:
            data (pd.DataFrame): dataframe with discharge
            hydrological_month (int): hydrological month for use for in the hydrological year

        Returns:
            pd.DataFrame: dataframe with peak discharges
        """
        # Create hydrological year column
        data = Hydrology.fill_hydrological_year(data, hydrological_month)

        # Calculate peak discharges
        maximum = data.groupby(by="Ano Hidro").max()[["Vazao"]]

        # Join with original data
        maximum = maximum.reset_index().set_index(["Ano Hidro", "Vazao"])
        maximum = maximum.join(
            data.reset_index().set_index(["Ano Hidro", "Vazao"]), how="left"
        )

        # Drop duplicates
        maximum = maximum[~maximum.index.duplicated()]

        # Sort by discharge
        maximum = maximum.sort_values(by="Vazao", ascending=False)
        maximum = maximum.reset_index(drop=False)

        # Drop undiserable columns
        maximum = maximum.drop(columns=["NivelConsistencia", "EstacaoCodigo"])

        maximum["Vazao"] = maximum["Vazao"].astype("float64").round(1)

        return maximum

    @staticmethod
    def recurring_time(Q, distr, *params) -> float:  # pylint: disable=C0103
        """Calculate the return time of a value, given a
        distribution and its parameters.

        Args:
            Q (float): Value (Discharge)
            distr (scipy.distribution): The distribution object

        Returns:
            float: Recurring time
        """
        prob = 1 - distr.cdf(Q, *params)
        return 1 / prob

    @staticmethod
    def fit_distribution(data: pd.Series, distr: str) -> Tuple[float, float]:
        """Fit a distribution to a data set and return the parameters

        Args:
            data (pd.Series): Series with discharge data
            distr (str): scipy distribution

        Returns:
            Tuple[float, float]: parameters of the distribution
        """
        distribution = getattr(stats, distr)
        args = distribution.fit(data)

        return args

    @staticmethod
    def plot_distribution_curve(distr: str, args: Tuple[float, float], ax: plt.Axes):
        """Plot a distribution curve

        Args:
            distr (str): scipy distribution
            args (Tuple[float, float]): parameters of the distribution
            ax (plt.Axes): matplotlib axes
        """

        # Get the scipy distribution object from its name
        distribution = getattr(stats, distr)

        # Calculate min and max x-values to plot
        min_x = distribution.ppf(0.0001, *args)
        max_x = distribution.ppf(0.9999, *args)
        x = np.linspace(min_x, max_x, 1000)

        ax.plot(x, distribution.pdf(x, *args), "r-", lw=2, label=f"Fitted {distr}")
        ax.legend()
        ax.set_title(f"Distribuição {distr}")
        ax.set_xlabel("Vazão (m³/s)")
        ax.set_ylabel("Densidade de probabilidade")

    @staticmethod
    def apply_distribution(maximum: pd.DataFrame, distr: str, ax: plt.Axes):
        """Apply a distribution to a data set. This includes the RT (Recurring Time)
        column to the dataframe, and the corresponding chart.

        Args:
            data (pd.DataFrame): dataframe with discharge column
            distr (str): scipy distribution
            ax (plt.Axes): matplotlib axes
        """
        # Get the scipy distribution object from its name
        distribution = getattr(stats, distr)

        # Fit the distribution
        args = Hydrology.fit_distribution(maximum["Vazao"], distr)

        # plot the corresponding chart
        ax.hist(maximum["Vazao"], bins=10, density=True)

        # Plot the distribution curve
        Hydrology.plot_distribution_curve(distr, args, ax)

        # add the RT column
        column_name = f"TR {distr}"
        maximum[column_name] = round(
            maximum["Vazao"].apply(
                Hydrology.recurring_time, args=(distribution, *args)
            ),
            1,
        )

    @staticmethod
    def apply_empiric_rt(maximum: pd.DataFrame):
        """Apply empirical RT to the dataframe

        Args:
            data (pd.DataFrame): dataframe with discharge column
        """
        # add the RT column
        column_name = "TR Empirico"
        n = len(maximum)
        maximum[column_name] = (n + 1) / (maximum.index + 1)
        maximum[column_name] = maximum[column_name].round(1)

    ###### MAIN PUBLIC METHODS ######
    def get_discharge(self, station: int) -> pd.DataFrame:
        """Get discharge for a given station

        Args:
            station (int): station number

        Returns:
            pd.DataFrame: dataframe with discharge
        """
        # Query database to retrieve discharge records
        query = f"""SELECT EstacaoCodigo, NivelConsistencia, vazao_val, vazao_data 
                    FROM hidro.pivotvazoes 
                    WHERE EstacaoCodigo = {station}"""

        # Read SQL query results into a DataFrame
        data = pd.read_sql(
            query,
            self.conn,
            parse_dates="vazao_data",
            dtype={
                "EstacaoCodigo": "int32",
                "NivelConsistencia": "uint8",
                "vazao_val": "float32",
            },
        )

        # Rename columns for clarity
        data = data.rename(columns=Hydrology.rename_columns)

        # Get highest quality level for each date
        keys = data[["Data", "NivelConsistencia"]].groupby("Data").max()
        keys = keys.reset_index(drop=False).set_index(["Data", "NivelConsistencia"])

        # Join data to keys
        data = data.set_index(["Data", "NivelConsistencia"])
        data = data.loc[keys.index].reset_index(drop=False)

        # Sort by date
        data = data.set_index("Data", drop=True).sort_index()

        # Round discharge values
        data["Vazao"] = data["Vazao"].round(2)

        # Drop NA rows
        data = data.dropna()

        return data

    def calc_return_times(
        self, data: pd.DataFrame, hydrological_month: int, distrs: List[str] = None
    ) -> Tuple[pd.DataFrame, plt.figure]:
        """Calculate the Return Times for the maximum Discharge values in each hydrological year

        Args:
            data (pd.DataFrame): dataframe with discharge
            hydrological_month (int): hydrological month for use for in the hydrological year
            distrs (List[str], optional): List of scipy distributions.
                If None, defaults to gumbel and lognormal.
        Returns:
           Tuple[pd.DataFrame: dataframe with RTs, figure: adjusted distrs]
        """
        if distrs is None:
            distrs = Hydrology.default_distrs

        # Get the maximum discharge for each hydrological year
        data = Hydrology.fill_hydrological_year(data, hydrological_month)
        maximum = Hydrology.calc_peak_discharges(data, hydrological_month)

        # apply the empirical RT
        Hydrology.apply_empiric_rt(maximum)

        # get the number of distributions to fit
        n = len(distrs)

        # create the plot canvas
        original_backend = plt.get_backend()
        plt.switch_backend("agg")
        fig, axs = plt.subplots(n, 1, figsize=(5, n * 6))

        for ax, distr in zip(axs, distrs):
            Hydrology.apply_distribution(maximum, distr, ax)

        # Switch back to the original backend
        plt.switch_backend(original_backend)

        return maximum, fig
