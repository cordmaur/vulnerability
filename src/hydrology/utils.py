"""Utility functions"""

import io
import base64
import warnings
from typing import Union, Tuple
from datetime import datetime
from dateutil.relativedelta import relativedelta

import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

from shapely import box


def months_between_dates(start_datetime: datetime, end_datetime: datetime):
    """_summary_

    Args:
        start_datetime (datetime): _description_
        end_datetime (datetime): _description_

    Returns:
        _type_: _description_
    """

    delta = relativedelta(end_datetime, start_datetime)
    months = delta.years * 12 + delta.months

    if delta.days > 0:
        months += 1

    return months


def timestamp_date(date: Union[str, datetime, pd.Timestamp]):
    """
    Convert input date to a timestamp without hour component.

    Parameters:
    date : str, datetime.datetime, or pd.Timestamp
        Input date in string, datetime, or timestamp format.

    Returns:
    pd.Timestamp
        Timestamp without hour component.
    """
    if isinstance(date, str):
        date = pd.to_datetime(date)
    elif isinstance(date, pd.Timestamp):
        pass  # No conversion needed for pd.Timestamp
    elif isinstance(date, datetime):
        date = pd.Timestamp(date)
    else:
        raise ValueError(
            "Unsupported input format. Supported formats are str, datetime.datetime, or pd.Timestamp."
        )

    # Remove the hour component
    # date_without_hour = date.replace(hour=0, minute=0, second=0)

    return date


def disable_warnings():
    """Disable some annoying warnings"""
    warnings.filterwarnings("ignore", message=".*buffer.*")
    warnings.filterwarnings("ignore", message=".*database.*")
    warnings.filterwarnings("ignore", message=".*incompletely.*")


def fig2base64(fig: plt.figure, dpi: int = 300) -> str:
    """Convert a Matplotlib figure to a base64 Unicode string
    Args:
        fig (plt.figure): Matplotlib figure to convert
        dpi (int, optional): Dots per inch. Defaults to 300.

    Returns:
        str: The figure encoded as a string.
    """
    # Save the figure as PNG into a BytesIO object
    png_buffer = io.BytesIO()
    fig.savefig(png_buffer, format="png", dpi=dpi, bbox_inches="tight")

    # Convert the binary PNG data to a base64-encoded string
    fig64 = base64.b64encode(png_buffer.getvalue()).decode("utf-8")
    return fig64


def calc_aspects_lims(
    shp: gpd.GeoDataFrame,
    aspect: float = 1.0,
    percent_buffer: float = 0,
    fixed_buffer: float = 0.0,
) -> Tuple[Tuple[float, float], Tuple[float, float]]:
    """
    Calculate the limits of a viewport given a GeoDataFrame, a buffer around the bounds (optional)
    and an aspect ratio: aspect_ratio = lim_x/lim_y
    the buffer can be expressed as crs units or percentage
    """

    # first, let's get the bounding box
    xmin, ymin, xmax, ymax = calc_bounds(
        shp=shp, percent_buffer=percent_buffer, fixed_buffer=fixed_buffer
    )

    # calc the sizes in each dimension
    size_x = xmax - xmin
    size_y = ymax - ymin

    actual_aspect = size_x / size_y

    # if actual aspect is smaller, that means width has to be increased
    if actual_aspect < aspect:
        # we have to increase X accordingly
        delta = size_y * aspect - size_x
        xmin -= delta / 2
        xmax += delta / 2

    # if actual aspect is greater, that means height has to be increased
    else:
        # we have to increase Y axis accordingly
        delta = size_x / aspect - size_y
        ymin -= delta / 2
        ymax += delta / 2

    # return the limits
    return (xmin, xmax), (ymin, ymax)


def calc_bounds(
    shp: gpd.GeoDataFrame, percent_buffer: float = 0, fixed_buffer: float = 0.0
) -> tuple:
    """
    Return the total bounds of a shape file with a given buffer
    The buffer can be a fixed distance (in projection units)
    or a percentage of the maximum size
    """

    # get the bounding box of the total shape
    bbox = box(*shp.total_bounds)

    if fixed_buffer != 0:
        bbox = bbox.buffer(fixed_buffer)
    elif percent_buffer != 0:
        xmin, ymin, xmax, ymax = bbox.bounds
        delta_x = xmax - xmin
        delta_y = ymax - ymin
        diag = (delta_x**2 + delta_y**2) ** 0.5
        bbox = bbox.buffer(percent_buffer * diag)

    return bbox.bounds
