"""Utility functions"""

import io
import base64
import warnings
from typing import Union, Tuple
from functools import wraps
from datetime import datetime
from dateutil.relativedelta import relativedelta


import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt

from shapely import box

Number = Union[float, int]


def non_interactive_backend(func):
    """
    Decorator to temporarily switch the Matplotlib backend to 'agg' (non-interactive)
    for the duration of the decorated function. This is useful for generating plots
    without displaying them, especially in environments like Jupyter notebooks where
    interactive backends may cause issues with large numbers of plots.

    Args:
        func (function): The function to be decorated.

    Returns:
        function: The wrapped function that temporarily switches the Matplotlib
                  backend to 'agg' during its execution.

    Example:
        @use_non_interactive_backend
        def plot_report_map(self):
            \"\"\"Plot the map figure for the report

            Returns:
                plt.figure: Matplotlib figure
            \"\"\"
            # create the plot canvas
            mapfig, axs = plt.subplots(1, 2, figsize=(14, 10))

            # plot the context
            ax = axs[0]
            self.plot_context(ax=ax)

            # plot the municipality
            ax = axs[1]
            self.plot_municipality(ax=ax, stations=True)

            return mapfig

        # This ensures that the 'agg' backend is used for the plot creation
        # and then switches back to the original backend afterwards.
    """

    @wraps(func)
    def wrapper(*args, **kwargs):
        original_backend = plt.get_backend()
        plt.switch_backend("agg")
        try:
            result = func(*args, **kwargs)
        finally:
            plt.switch_backend(original_backend)
        return result

    return wrapper


def logit(p: Number) -> Number:
    """
    Logit transformation function
    Compress data in both ends (negative and positive)
    It will be used instead of a standard logaritmic scale

    Args:
        p (Number): Value to be converted by the logit function

    Returns:
        Number: _description_
    """
    return np.log(p / (1 - p))


def inv_logit(logit_value: Number) -> Number:
    """
    Inverse logit function for custom tick labels
    Performs the inverse of the logit transformation, basically to
    display correctly the original probability scale on X axis
    Args:
        logit (Number): Logit value to be converted

    Returns:
        Number: Converted logit value
    """
    return np.exp(logit_value) / (1 + np.exp(logit_value))


def logit_formatter(x: Number, pos) -> str:
    """
    Formatter function to be used with FuncFormatter from matplotlib.
    Customize the x-axis value (in logit) to show the original probability scale.
    It get's the ticker value and returns a string to be used as a label.
    Args:
        x (Number): Label

    Returns:
        str: Label converted from the logit value received.
    """
    value = inv_logit(x)
    s = f"{inv_logit(x):.4f}".rstrip("0")

    if value <= 0.5:
        s += f"\nTR={1/value:.0f}"

    return s


def months_between_dates(start_datetime: datetime, end_datetime: datetime):
    """_summary_

    Args:
        start_datetime (datetime): _description_
        end_datetime (datetime): _description_

    Returns:
        _type_: _description_
    """

    delta = relativedelta(end_datetime, start_datetime)
    months = delta.years * 12 + delta.months

    if delta.days > 0:
        months += 1

    return months


def timestamp_date(date: Union[str, datetime, pd.Timestamp]):
    """
    Convert input date to a timestamp without hour component.

    Parameters:
    date : str, datetime.datetime, or pd.Timestamp
        Input date in string, datetime, or timestamp format.

    Returns:
    pd.Timestamp
        Timestamp without hour component.
    """
    if isinstance(date, str):
        date = pd.to_datetime(date)
    elif isinstance(date, pd.Timestamp):
        pass  # No conversion needed for pd.Timestamp
    elif isinstance(date, datetime):
        date = pd.Timestamp(date)
    else:
        raise ValueError(
            "Unsupported input format. Supported formats are str, datetime.datetime, or pd.Timestamp."
        )

    # Remove the hour component
    # date_without_hour = date.replace(hour=0, minute=0, second=0)

    return date


def disable_warnings():
    """Disable some annoying warnings"""
    warnings.filterwarnings("ignore", message=".*buffer.*")
    warnings.filterwarnings("ignore", message=".*database.*")
    warnings.filterwarnings("ignore", message=".*incompletely.*")


def fig2base64(fig: plt.figure, dpi: int = 300) -> str:
    """Convert a Matplotlib figure to a base64 Unicode string
    Args:
        fig (plt.figure): Matplotlib figure to convert
        dpi (int, optional): Dots per inch. Defaults to 300.

    Returns:
        str: The figure encoded as a string.
    """
    # Save the figure as PNG into a BytesIO object
    png_buffer = io.BytesIO()
    fig.savefig(png_buffer, format="png", dpi=dpi, bbox_inches="tight")

    # Convert the binary PNG data to a base64-encoded string
    fig64 = base64.b64encode(png_buffer.getvalue()).decode("utf-8")
    return fig64


def calc_aspects_lims(
    shp: gpd.GeoDataFrame,
    aspect: float = 1.0,
    percent_buffer: float = 0,
    fixed_buffer: float = 0.0,
) -> Tuple[Tuple[float, float], Tuple[float, float]]:
    """
    Calculate the limits of a viewport given a GeoDataFrame, a buffer around the bounds (optional)
    and an aspect ratio: aspect_ratio = lim_x/lim_y
    the buffer can be expressed as crs units or percentage
    """

    # first, let's get the bounding box
    xmin, ymin, xmax, ymax = calc_bounds(
        shp=shp, percent_buffer=percent_buffer, fixed_buffer=fixed_buffer
    )

    # calc the sizes in each dimension
    size_x = xmax - xmin
    size_y = ymax - ymin

    actual_aspect = size_x / size_y

    # if actual aspect is smaller, that means width has to be increased
    if actual_aspect < aspect:
        # we have to increase X accordingly
        delta = size_y * aspect - size_x
        xmin -= delta / 2
        xmax += delta / 2

    # if actual aspect is greater, that means height has to be increased
    else:
        # we have to increase Y axis accordingly
        delta = size_x / aspect - size_y
        ymin -= delta / 2
        ymax += delta / 2

    # return the limits
    return (xmin, xmax), (ymin, ymax)


def calc_bounds(
    shp: gpd.GeoDataFrame, percent_buffer: float = 0, fixed_buffer: float = 0.0
) -> tuple:
    """
    Return the total bounds of a shape file with a given buffer
    The buffer can be a fixed distance (in projection units)
    or a percentage of the maximum size
    """

    # get the bounding box of the total shape
    bbox = box(*shp.total_bounds)

    if fixed_buffer != 0:
        bbox = bbox.buffer(fixed_buffer)
    elif percent_buffer != 0:
        xmin, ymin, xmax, ymax = bbox.bounds
        delta_x = xmax - xmin
        delta_y = ymax - ymin
        diag = (delta_x**2 + delta_y**2) ** 0.5
        bbox = bbox.buffer(percent_buffer * diag)

    return bbox.bounds
