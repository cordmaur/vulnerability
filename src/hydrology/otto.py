""" 
This module implements the Otto class, responsible for all ottocodification processing
"""

import pandas as pd
import geopandas as gpd


class Otto:
    """General methods to work with the otto hydrography"""

    @staticmethod
    def get_upstream(
        reaches: gpd.GeoDataFrame, cobacia: str, cocursodagua: str
    ) -> gpd.GeoDataFrame:
        """The df should have the `cobacia` column for the upstream query to work"""
        upstream = reaches[reaches["cobacia"].str.startswith(cocursodagua)]
        upstream = upstream.query(f"cobacia >= '{cobacia}'")

        return upstream

    @staticmethod
    def get_combined_upstream(
        reaches: gpd.GeoDataFrame, to_search: gpd.GeoDataFrame
    ) -> gpd.GeoDataFrame:
        """
        Advanced version of the get_upstream function
        Select upstream reaches for all reaches that are listed in the to_search dataframe
        The to_search dataframe should have `cocursodag` and `cobacia` columns
        """
        df = to_search.sort_values(["cocursodag", "cobacia"]).copy()
        upstream = gpd.GeoDataFrame()

        while len(df) > 0:
            row = df.iloc[0]
            # be sure to drop this first element
            df = df.drop(index=row.name)

            # get elements upstream
            ups = Otto.get_upstream(reaches, row["cobacia"], row["cocursodag"])
            upstream = pd.concat([upstream, ups])

            # eliminate from df all elements already included
            df = df[~df["cobacia"].isin(upstream["cobacia"])]

        return upstream

    @staticmethod
    def get_touching(
        gdf: gpd.GeoDataFrame,
        obj: gpd.GeoDataFrame,
        buffer: float = 1e-3,
        auto_increase: bool = False,
    ) -> gpd.GeoDataFrame:
        """Return the features on gdf that touches the obj, considering a buffer.
        The procedure will calculate the convex hull and then apply the buffer.
        If auto_increase is True, it will increase the buffer until touch.
        Args:
            gdf (gpd.GeoDataFrame): GeoDataFrame with the features to filter
            obj (gpd.GeoDataFrame): Object to be intersected.
            buffer (float, optional): Buffer in degrees. 1deg = aprox. 111km
            Defaults to 1e-3 = 100m.
            auto_increase (bool, optional): Automatically increase buffer size to force a touch
        Returns:
            gpd.GeoDataFrame: gdf with the features that touches the obj
        """

        # first let's get all the reaches that touches the urban area, considering a buffer
        hull = obj.dissolve().convex_hull

        # set a multiplier to increase buffer size (in case of auto_increase)
        mult = 1.0
        features = gpd.GeoDataFrame()

        while len(features) == 0:
            # create a convex hull and apply a buffer to it
            buffered_hull = gpd.GeoDataFrame(hull.buffer(buffer * mult))
            buffered_hull = buffered_hull.set_geometry(0)

            features = gdf.sjoin(buffered_hull, how="left", predicate="intersects")
            features = features[
                ~pd.isna(features["index_right"])  # pylint: disable=E1130
            ]

            mult = mult * 2

            if not auto_increase:
                break

        return features

    @staticmethod
    def get_downstream(features: gpd.GeoDataFrame, cobacia: str) -> gpd.GeoDataFrame:
        """Get features downstream the cobacia

        Args:
            features (GeoDataFrame): The features dataframe mto select. Should have "cobacia",
            "cocursodag", "noorigem" and "nodestino" fields.
            cobacia (str): Reach code to start the downstream walk

        Returns:
            gpd.GeoDataFrame: GeoDataFrame with the downstream features selected
        """

        # create a geodataframe to store the downstream features
        # downstream = gpd.GeoDataFrame()

        # select the starting row
        row = downstream = features.query(f"cobacia == '{cobacia}'")
        while not (
            row["cocdadesag"].iloc[0] == "" or row["cocdadesag"].iloc[0] is None
        ):
            downstream = pd.concat([downstream, row], axis=0)

            row = features.query(f"noorigem == {row['nodestino'].iloc[0]}")

        return downstream.drop_duplicates()
